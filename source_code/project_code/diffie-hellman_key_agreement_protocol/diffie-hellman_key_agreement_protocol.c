/* INTENTED PROGRAM WORKINGS:
 * This program is supposed to illustrate the mathematical mechanics of the Diffie-Hellman key agreement protocol.
 *
 * First I interpret the proposed multiplicative group of integers to be used in my example protocol run from my first supplied terminal argument (argv[0] or more simplisticly *argv).
 *
 * Then I start to calculate the cardinalities of the subgroups generated by the elements of said multiplicative group (the length of the rows displayed by "./general_subpublic_base")
 *
 * Then I ask what secret numbers Alice and Bob pick.
 *
 * Then I showcase the magic trick.
 */
#include <stdio.h>
#include "../../libraries/mathematics/maths.h"
#include "../../libraries/functional/string.h"
// LIBRARY INCLUSIONS

#define ADDITIVE_IDENTITY 0
#define MULTIPLICATIVE_IDENTITY 1
// NEEDED MATHEMATICAL DEFINITIONS

const char *SYNTAX_ERROR = "INCOMPREHENSIBLE SYNTAX. Returning -1.\n";
const char *REQUIRED_SYNTAX = "MINIMUM REQUIRED SYNTAX:";
const char *FULL_SYNTAX = "MAXIMUM SUPPORTED SYNTAX:";
const char *NECESSARY_INPUT_CLAUSE = "<group modulus>";
const char *SUPPLEMANTARY_INPUT_CLAUSE = "<group generator>";
// ERROR MESSAGES

int main(int argc, char **argv) {
    unsigned long public_modulus, public_base;
    // DEFINE PROGRAM VARIABLES

    if (argc == 2) {
	public_modulus = ul_from_str(argv[1]);
    } else {
	fprintf(stderr, "%s\n\n", SYNTAX_ERROR); // << NOTIFY SOMETHING HAS GONE WRONG
	fprintf(stderr, "%s\n", REQUIRED_SYNTAX); // < SHOWCASE LEAST REQUIRED INPUT 
	fprintf(stderr, "	%s %s\n\n", *argv, NECESSARY_INPUT_CLAUSE);
	fprintf(stderr, "%s\n", FULL_SYNTAX); // < SHOWCASE THE APPRECIATED FORM OF INPUT
	fprintf(stderr, "	%s %s %s\n", *argv, NECESSARY_INPUT_CLAUSE, SUPPLEMANTARY_INPUT_CLAUSE);
	return -1;
    } fprintf(stdout, "Proposed multiplicative group \u2124_%lu*\n", public_modulus);

    // fprintf(stdout, "\nStarting a listing of the elements of \u2124_%lu* along with their respective subgroup orders:", public_modulus);
    for (public_base = 2; public_base < public_modulus; public_base++) {
	if (GCD(public_modulus, public_base) == MULTIPLICATIVE_IDENTITY) { // <<< If the potential base number is in the multiplicative group of integers mod <group modulus>
	    unsigned long subgroup_order = MULTIPLICATIVE_IDENTITY;
	    for (unsigned long iter = public_base; iter != MULTIPLICATIVE_IDENTITY; iter = (iter * public_base) % public_modulus)
		subgroup_order++;
	    // ^^ Determine subgroup order

	    fprintf(stdout, "\n|<%lu>| = %lu", public_base, subgroup_order);
	    // ^^ Echo subgroup order

	    if (subgroup_order == public_modulus - 1) { // << If the verified base number of the multiplicative group generates the entire group
		fprintf(stdout, "= Generates the entire group \u2124%lu* !\n", public_modulus);
		char yes_no_answer; do {
		    fprintf(stdout, "Use this number as base for creating a DLP (discrete logarithm problem) \u2124%lu* ? (y/n): ", public_modulus);
		    fscanf(stdin, "%c", &yes_no_answer);
		} while ( !(yes_no_answer == 'Y' || yes_no_answer == 'y') && !(yes_no_answer == 'N' || yes_no_answer == 'n'));
		// ^^ Acquire sense of where the user want to take me

		if (yes_no_answer == 'N' || yes_no_answer == 'n') continue;
		// ^^ Look for next suitable generator is user is not content
	    } }
	fprintf(stdout, "\nSettled with base number %lu as generator.\n", public_base);
	// ^^ Settled with the user about the generator
	
	unsigned long private_alice, private_bob, public_alice, public_bob;
	// ^^^^ Prepare calculation variables

	fprintf(stdout, "Secret value Alice picks: ");
	fscanf(stdin, "%lu", &private_alice);
	// ^^^^ Settle with user on what secret exponet Alice decides to use

	fprintf(stdout, "Secret value Bob picks: ");
	fscanf(stdin, "%lu", &private_bob);
	// ^^^^ Settle with user on what secret exponent Bob decides to use

	public_alice = mod_exponentiate(public_base, private_alice, public_modulus);
	fprintf(stdout, "\n\nNow Alice's calculation would go as follows:\n");
	fprintf(stdout, "%lu^%lu = %lu (%% %lu)\n", public_base, private_alice, public_alice, public_modulus);
	// ^^^^ Simulate Alice's end (before open-channel communication)

	public_bob = mod_exponentiate(public_base, private_bob, public_modulus);
	fprintf(stdout, "\n\nAnd Bob's calculation goes like this:\n");
	fprintf(stdout, "%lu^%lu = %lu (%% %lu)\n", public_base, private_alice, public_bob, public_modulus);
	// ^^^^ Simulate Bob's end (before open-channel communication)

	fprintf(stdout, "\n\n\n##### AND NOW THE HEART OF THE TRICK #####\n");
	fprintf(stdout, "Value Alice receives from Bob: %lu\n", public_bob);
	fprintf(stdout, "Value Bob receives from Alice: %lu\n", public_alice);
	// ^^^^ Simulate open-channel communication (exchange of permutations)

	fprintf(stdout, "\n\nValue Alice calculates from the permutation she received from Bob:\n");
	unsigned long alices_shared_secret = mod_exponentiate(public_bob, private_alice, public_modulus);
	fprintf(stdout, "%lu^%lu = %lu (%% %lu)\n", public_bob, private_alice, alices_shared_secret, public_modulus);
	// ^^^^ Back on Alice's side

	fprintf(stdout, "\n\nValue Bob calculates from the permutation he received from Alice:\n");
	unsigned long bobs_shared_secret = mod_exponentiate(public_alice, private_bob, public_modulus);
	fprintf(stdout, "%lu^%lu = %lu (%% %lu)\n", public_alice, private_bob, bobs_shared_secret, public_modulus);

	if (alices_shared_secret == bobs_shared_secret) {
	    fprintf(stdout, "Calculation successfull!\n\n");
	} else  {
	    fprintf(stderr, "Calculation unsuccessfull!\n\n");
	    return -1;
	}
	// ^^^^ Back on Bob's side
    } fprintf(stderr, "Ran out of options ...\n"); return 0;
}
